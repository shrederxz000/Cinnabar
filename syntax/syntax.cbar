package "main"; //package name

// --------INPORTS---------
plug std.io; //import
plug std.panic; //i dont know, where will be panices

/*
plug libs.lib1:func1 as function //import example
*/

// ------VARRIBLES-------

/* VARRIBLE TYPES */
/*
int - Integer int = int32
    int8
    int16
    int32
    int64
    int128

uint - Union Integer uint = uint32
    uint8
    uint16
    uint32
    uint64
    uint128

float - Float  float = float32
    float32
    float64

!auto types give in compile, for don't lose persormance

bool - Boolian
string - String 
char - Symbol

list - List (Dunamic array, like a vector in Rust). Elements of list may be different types
tuple - Tuple. Elements of Tuple may be different types. Static (Don't dynamic) 
array - Array (Static array). All elements of array must one type

hash - Hashmap
hashlist - Hahsmap List (like a set in Python, key: arg, value:Null)
*/


let x := 5; // var muttable
let may_be_null?; //may keep null (let only, use then change value of var from Nil)

/*
    MODIIFICATORS

    Modificators may be a package without impl. (like a GO), 
    or implementations (like classic OOP, like a Java)
    
	priv - Private
	pub - Public (default)
	static - Static. May call a methods without create a object of impl.
*/

set z := 1; // var immutable 
let x : int  = 3; //var muttable
const y : int = 4; // const

set a := 2;
set b := 8;

set num1 := 6;
set num2 := 2;

set num1 = num1 as float; //shadowing vars
set num2 = num1 as float; //redeclarativing
/* 
	shadoing rules
	if you redeclarate set: set shadow
	if you redeclarate let: let not shadow, change value
	if you redeclarative const: PANIC!!!

*/


// --------FUNCTIONS--------

//var pow will be 64
set pow :int = lambda(a, b) => a ** b; //type of var = returning lambda type 


void summator(a:int, b:int) {
	take a+b; //return
}
void summator2(a:int, b:int) {
	return a+b; // return is aliacse take. return = take
}

void multimmator<T: int | float>(a, b): Optional<int | float> { 
/* return type (int or float). if don't write return type, then type will be automatic */
	a * b //return here, if don't write ;
}

// Optional and generics 
void null_or_digit(input:int): Optional<Nil | int> {
    match input {
        == 0 => take nil;
        _ => take input;
    }
}

// --------CONDITION BRANCES------------

set age = 18;
match age {
	>= 18 => io.println("welcome to the bar");
	< 18  => io.println("go away");
	_ => throw panic.ValueError; //throw error
}

name := "Alice";
match name => == "Alice" => io.println("you Alice!"); // short write, 

/* 
short write, then "_ =>" return Nil (null)
for eximple, i write classic this match pattetn:
*/

name := "Bob";
match name {
    == "Bob" => io.println("you Bob");
    _ => take Nil; // may dont write this, will be default action
}

/*
my rules let short whis lines to 1 line (like line with Alice):
*/

name := "Kate";
match name => == "Kate" => io.println("you Kate"); 

// -------ERRORS EXEPTIONS-------------

try {
	set res = num1 / num2;

	catch e => io.println($"error {e}"); //short writing

	catch e == panic.ZeroDivision { //classic writing
		io.println("НА НОЛЬ ДЕЛИТЬ НЕЛЬЗЯ");
    }

	finally => io.println("res = {res}");
}

// -------LOOPS----------

loop { // i>=10 condition, then loop must finish
	let i = 0;
	io.println($"loop no {i}");
	j+=1;
	match i {
		== 10 => break; 
		_ => continue; 
    }
}

running = true;
loop { 
	let j = 0;
	io.println($"loop no {j}");
	j+=1;
	match j {
		>= 20 => running = false;
		_ => continue;
		
    }
}
//----UPDATE-----
loop (let i:= 0; i<=100; i+=1){ // while condition is doing, loop spinning
    io.println($"itaration No: {i}");
    
} // if don't doing, when loop breaking


running2 := true 
loop (running=true){
    world = io.inputln();
    match world {
        == "stop" => running2 = false;
        _ => continue; // in new version may don't write 
    }
}


// -------OOP-------

ifce Animals { // interface
	void new(), // declarative method
	void animal_voice() { // may write by defautlt action of function
        io.println("some sound");
    }, 
	void fly_status(),
} 

scatch Animal {
	can_fly: bool,
	voice: string,

    impl Animal(Animals) { //implements interface Animals
        void $new (can_fly, voice):self { //magic method $new()
            //return self default (i created then show return type)
            self.can_fly = can_fly;
            self.voice = voice;
        }

        void animal_voice(self) {
            io.println($"voice: {self.voice}");
        }

        void fly_status(self):bool { 
            take self.fly;
        } 

    }

    impl Duck (Animals) {  
        void new(can_fly:bool=true, voice:string="crack-crack") { //func args with default values 

            self.duck = new Animal(can_fly=can_fly, voice=voice); 

            /* if name of arg and name of var are intanse, 
            then will be automatic correspondence of names */ 

        }

        void animal_voice(self) {
            self.duck.animal_voice(); 
        }

        void fly_status(self):bool => take self.duck.fly_status(); 
        /* =>  syntax sugar doing for lambda, but may use in simple funtions. 
         write one action without write {...} */
         }
}

// -------UTILS-------

/*
    Decorators

    Instruction to make decorator:
*/
    make_deco!(func) { //make_deco() will be macros
        void speedtest(logging:bool) { //args of decorator
            void deco<AnyTypes>(AnyArgs) { //decorator
                let start := time.now();
                let result := func<AnyTypes>(AnyArgs);
                let duration := time.now() - start;
                io.println($"duration: {duration}");
                return None;
            }
            match logging => == true { 
                io.println("func starts");
                set res = deco(); 
                io.println("func finished");
            return res;
            } // return speedtest here automatic
        }
    }
/*
    Practice use:
*/

    @sppedtest(logging=true)
    void long_func(wait: int) {
        io.println("func sleeps");
        time.sleep(wait);
        io.println($"func awake");
    } 


    // Macroses

    make_macro!(a, b) {
        macro add<T: int | float>(a, b) {
            quote {
                a + b
            }
        }
    }

    make_macro!(a+b) {
        macro twice<T: int | float>(a+b) {
            quote {
                (unquote(a+b)) * 2;
            }
        }
    }

    set x := add!(5, 3); // set x := 5 + 3
    set y := twice(7); //set y := (7 + 4) * 2

    In-Compile Calculate
    const SIZE = comptime!(2 ** 5);

