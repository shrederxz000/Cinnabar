package "main" //package name

// --------INPORTS---------
plug std.io //import
plug std.panic //i dont know, where will be panices

/*
plug libs.lib1:func1 as function //import example
*/

// ------VARRIBLES-------

/* VARRIBLE TYPES */
/*
int - Integer int = int32
    int8
    int16
    int32
    int64
    int128

uint - Union Integer uint = uint32
    uint8
    uint16
    uint32
    uint64
    uint128

float - Float  float = float32
    float32
    float64

!auto types give in compile, for don't lose persormance

bool - Boolian
string - String 
char - Symbol

list - List (Dunamic array, like a vector in Rust). Elements of list may be different types
tuple - Tuple. Elements of Tuple may be different types. Static (Don't dynamic) 
array - Array (Static array). All elements of array must one type

hash - Hashmap
hashlist - Hahsmap List (like a set in Python, key: arg, value:Null)
*/


let x := 5 // var muttable
let may_be_null? //may keep null (let only, use then change value of var from Nil)

/*
    MODIIFICATORS

    Modificators may be a package without impl. (like a GO), 
    or implementations (like classic OOP, like a Java)
    
	priv - Private
	pub - Public (default)
	static - Static. May call a methods without create a object of impl.
*/

set z := 1 // var immutable 
let x : int  = 3 //var muttable
const y : int = 4 // const

set a := 2
set b := 8

set num1 := 6
set num2 := 2

set num1 = map(float, num1) //shadowing vars
set num2 = map(float, num2) //redeclarativing
/* 
	shadoing rules
	if you redeclarate set: set shadow
	if you redeclarate let: let not shadow, change value
	if you redeclarative const: PANIC!!!

*/


// --------FUNCTIONS--------

//var pow will be 64
set pow :int = (a, b) => a ** b //type of var = returning lambda type 


void summator(a:int, b:int) do
	take a+b //return
end
void summator2(a:int, b:int) do
	return a+b // return is aliacse take. return = take
end

void multimmator<T: int | float>(a, b): Optional<int | float> do 
/* return type (int or float). if don't write return type, then type will be automatic */
	a * b //return here
end

// Optional and generics 
void null_or_digit(input:int): Optional<Nil | int> do 
    match input do
        == 0 => take nil
        _ => take input
    end
end

// --------CONDITION BRANCES------------

set age = 18
match age do
	>= 18 => io.print("welcome to the bar")
	< 18  => io.print("go away")
	_ => throw panic.ValueError //throw error
end

name := "Alice"
match name => == "Alice" => io.print("you Alice!") // short write, 

/* 
short write, then "_ =>" return Nil (null)
for eximple, i write classic this match pattetn:

name := "Bob"
match name do
    == "Bob" => io.print("you Bob")
    _ => take Nil // may dont write this, will be default action

my rules let short whis lines to 1 line (like line with Alice):
name := Kate"
match name => == "Kate" => io.print("you Kate")
 */ 

// -------ERRORS EXEPTIONS-------------

try do
	set res = num1 / num2
	catch e => io.print($"error {e}") //short writing
	catch e == panic.ZeroDivision do //classic writing
		io.print("НА НОЛЬ ДЕЛИТЬ НЕЛЬЗЯ") 
	end
	finally => io.print("res = {res}")
end

// -------LOOPS----------

loop do // i>=10 condition, then loop must finish
	let i = 0;
	io.print($"loop no {i}");
	j+=1;
	match i do
		== 10 => break 
		_ => continue 
end

running = true;
loop do 
	let j = 0;
	io.print($"loop no {j}");
	j+=1;
	match j do
		>= 20 => running = false;
		_ => continue
		
end


// -------OOP-------

ifce Animals do // interface
	void new(), // declarative method
	void animal_voice() do // may write by defautlt action of function
        io.print("some sound")
    end, 
	void fly_status(),
end 

scatch Animal do
	can_fly: bool,
	voice: string,

    impl Animal(Animals) do //implements interface Animals
        void new (can_fly, voice):self do //return self default (i created then show return type)
            self.can_fly = can_fly
            self.voice = voice
        end

        void animal_voice(self) do
            io.print($"voice: {self.voice}")
        end

        void fly_status(self):bool do 
            take self.fly
        end 

    end

    impl Duck (Animals) do  
        void new(can_fly:bool=true, voice:string="crack-crack") do //func args with default values 

            self.duck = new Animal(can_fly=can_fly, voice=voice) 

            /* if name of arg and name of var are intanse, 
            then will be automatic correspondence of names */ 

        end

        void animal_voice(self) do
            self.duck.animal_voice() 
        end

        void fly_status(self):bool => take self.duck.fly_status() 
        /* =>  syntax sugar doing for lambda, but may use in simple funtions. 
         write one action without write do...end */
    end
end

// -------UTILS-------

/*
    Decorators

    Instruction to make decorator:

    make_deco!(func) do //make_deco() will be macros
        void speedtest(logging:bool) do //args of decorator
            void deco<AnyTypes>(AnyArgs) do //decorator
                let start := time.now()
                let result := func<AnyTypes>(AnyArgs)
                let duration := time.now() - start
                io.print($"duration: {duration}")
                return None
            end
            match logging => == true do 
                io.print("func starts")
                set res = deco() 
                io.print("func finished")
            return res
        end // return speedtest here automatic
    end

    Practice use:

    @sppedtest(logging=true)
    void long_func(wait: int) do
        io.print("func sleeps")
        time.sleep(wait)
        io.print($"func awake")
    end 



    Macroses

    make_macro!(a, b) do
        macro add<T: int | float>(a, b) do
            quote do
                a + b
            end
        end
    end

    make_macro!(a+b) do
        macro twice<T: int | float>(a+b) do
            quote do
                (unquote(a+b)) * 2
            end
        end
    end

    set x := add!(5, 3) // set x := 5 + 3
    set y := twice(7) //set y := (7 + 4) * 2

    In-Compile Calculate
    const SIZE = comptime(2 ** 5)
*/
